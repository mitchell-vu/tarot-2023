export default "float blendOverlay(float base, float blend) {\n\treturn base<0.5?(2.0*base*blend):(1.0-2.0*(1.0-base)*(1.0-blend));\n}\n\nvec3 blendOverlay(vec3 base, vec3 blend) {\n\treturn vec3(blendOverlay(base.r,blend.r),blendOverlay(base.g,blend.g),blendOverlay(base.b,blend.b));\n}\n\nvec3 blendOverlay(vec3 base, vec3 blend, float opacity) {\n\treturn (blendOverlay(base, blend) * opacity + base * (1.0 - opacity));\n}\n\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\n\nvarying vec2 vUv;\n\nuniform float time;\nuniform vec2 resolution;\nuniform vec3 backgroundColor;\nuniform vec3 lightColor;\nuniform float lightRadiusMultiplier;\nuniform vec2 lightPosition;\nuniform sampler2D cloudTexture;\nuniform vec2 pos;\nuniform float cloudReposition;\n\nvec4 circle(vec2 uv, vec2 pos, float rad, vec3 color) {\n    float d = length(pos - uv) + 1.0;\n    float t = clamp(d, 0.0, 1.0);\n    return vec4(color * (1.0 - smoothstep(0., rad, d)) * 15.0, 1.0 - t * 0.975);\n}\n\nvec2 textureUv(sampler2D texture, vec2 resolution, vec2 coord) {\n    ivec2 textureSize = textureSize(texture, 0);\n    float textureAspectRatio = float(textureSize.y) / float(textureSize.x);\n\n    float a1, a2;\n\n    if (resolution.y / resolution.x < textureAspectRatio) {\n        a1 = 1.0;\n        a2 = resolution.y / resolution.x / textureAspectRatio;\n    } else {\n        a1 = (resolution.x / resolution.y) * textureAspectRatio;\n        a2 = 1.0;\n    }\n\n    vec2 uv = coord / resolution;\n    uv = (uv - vec2(0.5)) * vec2(a1, a2) + vec2(0.5);\n\n    return uv;\n}\n\nvec2 rotateUV(vec2 uv, float rotation)\n{\n    float mid = 0.5;\n    return vec2(\n    cos(rotation) * (uv.x - mid) + sin(rotation) * (uv.y - mid) + mid,\n    cos(rotation) * (uv.y - mid) - sin(rotation) * (uv.x - mid) + mid\n    );\n}\n\nvoid main() {\n    vec2 uv = gl_FragCoord.xy;\n    float aspectRatio = resolution.x / resolution.y;\n\n    vec2 cloudUv = textureUv(cloudTexture, resolution, gl_FragCoord.xy);\n\n    vec2 cloud1Uv = rotateUV(cloudUv, 2.95);\n\n    if (aspectRatio > 1.0) {\n        cloud1Uv = cloud1Uv * 0.65 - vec2(0.25 + pos.x + cloudReposition, -0.09 + pos.y);\n    } else {\n        cloud1Uv = cloud1Uv * 0.7 - vec2(0.15 + pos.x + cloudReposition, -0.225 + pos.y);\n    }\n\n    vec4 textureCloud1 = texture(cloudTexture, cloud1Uv);\n    vec3 cloud1 = blendOverlay(backgroundColor, textureCloud1.rgb, 0.45);\n\n    vec2 cloud2Uv = rotateUV(cloudUv, 2.95);\n\n    if (aspectRatio > 1.0) {\n        cloud2Uv = cloud2Uv - vec2(0.55 + pos.x * 5.0 + (cloudReposition * 0.9), -0.25);\n    } else {\n        cloud2Uv = cloud2Uv - vec2(0.275 + pos.x * 5.0 + (cloudReposition * 0.9), -0.45);\n    }\n\n    vec4 textureCloud2 = texture(cloudTexture, cloud2Uv);\n    vec3 cloud2 = blendOverlay(cloud1, textureCloud2.rgb, 0.25);\n\n    vec2 cloud3Uv = cloudUv;\n    cloud3Uv = cloud3Uv * 0.7 - vec2(0.05 + pos.x * 1.5 + cloudReposition, -0.25 + pos.y * 1.5);\n\n    vec4 textureCloud3 = texture(cloudTexture, cloud3Uv);\n    vec3 cloud3 = blendOverlay(cloud2, textureCloud3.rgb, 0.45);\n\n    vec2 cloud4Uv = cloudUv;\n    cloud4Uv = cloud4Uv * 0.8 - vec2(0.05 - pos.x + cloudReposition * 0.9, -0.65) ;\n\n    vec4 textureCloud4 = texture(cloudTexture, cloud4Uv);\n    vec3 cloud4 = blendOverlay(cloud3, textureCloud4.rgb, 0.35);\n\n    vec4 backgroundLayer = vec4(cloud4, 1.0);\n\n    float lightRadius = 0.5 * resolution.y * lightRadiusMultiplier;\n    vec4 lightLayer = circle(uv, lightPosition, lightRadius, lightColor);\n\n    gl_FragColor = mix(backgroundLayer, lightLayer, lightLayer.a);\n}\n";